<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>什么是JVM | zxj</title><meta name="author" content="Xiangjie"><meta name="copyright" content="Xiangjie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="什么是JVMJVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是JVM">
<meta property="og:url" content="https://awslzhang.top/2020/06/14/%E4%BB%80%E4%B9%88%E6%98%AFJVM/index.html">
<meta property="og:site_name" content="zxj">
<meta property="og:description" content="什么是JVMJVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/06/14/fGXnluFNIw3hgZj.jpg">
<meta property="article:published_time" content="2020-06-14T07:59:55.000Z">
<meta property="article:modified_time" content="2021-01-01T05:50:00.047Z">
<meta property="article:author" content="Xiangjie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/06/14/fGXnluFNIw3hgZj.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://awslzhang.top/2020/06/14/%E4%BB%80%E4%B9%88%E6%98%AFJVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Xiangjie","link":"链接: ","source":"来源: zxj","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-01-01 13:50:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="zxj" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/06/14/fGXnluFNIw3hgZj.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zxj</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">什么是JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-14T07:59:55.000Z" title="发表于 2020-06-14 15:59:55">2020-06-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-01T05:50:00.047Z" title="更新于 2021-01-01 13:50:00">2021-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>一句话，JVM可以用下图表达。</p>
<p><img src="https://i.loli.net/2020/06/14/UeHY4PuDzcNi387.png" alt="image-20200614160517465"></p>
<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><p>如上面的图所示，其中中间区域，<strong>亮色的部分是共享区域，且存在垃圾回收机制；其余灰色部分是线程私有，不存在垃圾回收机制。</strong></p>
<h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h2><p>负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成<strong>方法区</strong>中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p>
<p><strong>方法区</strong>存放的是这个类的类模板，<strong>类的Class类</strong>、静态常量以及普通常量。</p>
<p>例如，下面的流程：</p>
<p><img src="https://i.loli.net/2020/06/14/sUM3eFiVlyXNDuo.png" alt="image-20200614160728184"></p>
<h3 id="ClassLoader的种类及作用"><a href="#ClassLoader的种类及作用" class="headerlink" title="ClassLoader的种类及作用"></a>ClassLoader的种类及作用</h3><p>ClassLoader的种类有3+1种：三种为Java自带、一种为用户自定义</p>
<p>Java自带的ClassLoader有：</p>
<ol>
<li>Bootstrap(C++)：启动类加载器，负责加载Java自带的类(<code>JAVA_HOME/jre/lib/tr.jar</code>中的)，例如java.lang就在这里面</li>
<li>Extension：扩展类加载器，扩展的类由这个加载器加载(<code>JAVA_HOME/jre/lib/ext/*.jar</code>)，例如swing的类就在这里</li>
<li>AppClassLoader：应用程序类加载器，用户编写的类由这个ClassLoader加载。加载当前项目classpath的类</li>
</ol>
<p>用户自定义的ClassLoader：</p>
<ol>
<li><code>Java.lang.ClassLoader</code>的子类，用户可以定制类的加载方式</li>
</ol>
<p>参考下面的图：</p>
<p><img src="https://i.loli.net/2020/06/14/XVNOFrPKmYvZdEg.png" alt="image-20200614161648514"></p>
<p>由图可知，这些类都是继承关系，其中<code>Bootstrap</code>是顶级类。</p>
<p>我们可以编写一个程序来证明上述说的类加载器的对错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(o.getClass().getClassLoader().getParent().getParent());<span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">        System.out.println(o.getClass().getClassLoader().getParent());<span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">        System.out.println(o.getClass().getClassLoader());<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent().getParent());<span class="comment">// null</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent());<span class="comment">// jdk.internal.loader.ClassLoaders$PlatformClassLoader@58ceff1</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader());<span class="comment">// jdk.internal.loader.ClassLoaders$AppClassLoader@2437c6dc</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的结果可以说明：</p>
<ol>
<li>自带类<code>Object</code>的类加载器是<code>Bootstrap</code>，因为它是C++编写，所以Java的控制台无法展示。<code>Bootstrap</code>没有父类，所以会报错。</li>
<li>自定义类<code>MyObject</code>的类加载器是<code>AppClassLoader</code>，而查找它的父类分别是<code>PlatformClassLoader</code>、<code>Bootstrap</code>证明它们之间是有继承关系的。</li>
</ol>
<p>这里小伙伴们可能纳闷不是说是<code>Extension</code>吗，怎么成<code>PlatformClassLoader</code>了，这里是因为我是用的是jdk11版本。<code>PlatformClassLoader</code>是jdk9 之后用来代替<code>ExtClassLoader</code> 的加载器，用来加载 jdk 中的非核心模块类。</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制其实就是类加载器的加载顺序。</p>
<p>当一个类加载器收到了类加载请求，<strong>它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成</strong>，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器其中，<strong>只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载</strong>。如果所有的子类都无法加载这个类，会出现异常<code>ClassNotFound</code>。</p>
<p>举个例子，上面的代码中类<code>MyObject</code>的加载过程：</p>
<ol>
<li>因为是用户自己编的，所以交给<code>APPClassLoader</code>去加载这个类，但是因为双亲委派机制。它把这个类加载请求交给了<code>PlatformClassLoader</code></li>
<li>同上，它也把这个类加载请求交给了<code>Bootstrap</code></li>
<li><code>Bootstrap</code>收到了请求，它发现自己无法加载这个类(它没有找到这个类的.class)，它交给了<code>PlatformClassLoader</code></li>
<li>同上，它又交给了<code>APPClassLoader</code></li>
<li><code>APPClassLoader</code>加载成功。</li>
</ol>
<p><strong>双亲委派的好处</strong></p>
<p>对于任意使用者自定义的 ClassLoader，都会先去尝试让 jvm 的 Bootstrap ClassLoader 去尝试加载(自定义的 ClassLoader 都继承了它们)。那么就能保证 jvm 的类会被优先加载(保证用户编写的代码不会污染jdk源代码)，限制了使用者对 jvm 系统的影响。</p>
<p><strong>双亲委派机制导致的沙箱机制</strong></p>
<p>请运行一下代码jdk8环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;code is not run&quot;</span>);<span class="comment">// 找不到main错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们自己创建了<code>java.lang.String</code>这与jdk自带的冲突，代码报的错误却是找不到main函数错误。因为<code>APPClassLoader</code>收到了<code>java.lang.String</code>的加载请求，由于双亲委派机制，最后这个请求被<code>Bootstrap</code>加载了，然后这个类加载请求就结束了；它加载的是jdk中的String。因为它没有main，所以报出了这个错误。</p>
<p>沙箱机制就是以防自己写的代码覆盖了jdk的源代码，所以它首先加载jdk的类，一旦加载成功，就不加载了。</p>
<h2 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h2><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<p>这里多说一句，执行的方法是被放入栈中的，但native方法是放入本地方法栈中的。</p>
<p>什么是本地方法？被native修饰的方法。这类方法只有声明，没有实现。实现靠的是第三方的库。</p>
<p>例如：<code>new Thread().start()</code>的<code>start()</code>调用的就是<code>private native void start0();</code></p>
<h2 id="本地方法接口-Native-Interface"><a href="#本地方法接口-Native-Interface" class="headerlink" title="本地方法接口(Native Interface)"></a>本地方法接口(Native Interface)</h2><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。</p>
<p> 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。    </p>
<h2 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h2><p>程序计数器是线程私有的，即每个线程都有一个程序计数器。他就是一个指针指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p>
<p>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>如果执行的是一个Native方法，那这个计数器是空的。</p>
<p>用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误</p>
<h2 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h2><p>供各线程共享的运行时内存区域。它存储了每一个类的结构信息Class，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space,java7)和元空间(Metaspace,java8)。</p>
<p>But,实例变量存在堆内存中,和方法区无关</p>
<p>所有线程所共享的区域，存在较少的垃圾回收</p>
<p>虽然java虚拟机规范把方法区描述为堆的一部分，但是他还有个别名叫做Non-heap（非堆），目的应该是与java堆区分开来。</p>
<p>java7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变</p>
<p> java7中，只是把字符串池和类的静态变量移到堆</p>
<p>java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中</p>
<h2 id="Java栈-Stack"><a href="#Java栈-Stack" class="headerlink" title="Java栈(Stack)"></a>Java栈(Stack)</h2><p>Java中栈管运行，堆管存储。</p>
<p>一般Java程序报错时，都是打印栈信息，因为栈保存着程序的运行轨迹。</p>
<p>栈是线程私有的，每个线程创建时都会创建一个独有的栈，线程结束栈内存释放。</p>
<p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。</strong></p>
<h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，</p>
<p>A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，</p>
<p>B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，</p>
<p>……</p>
<p>执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……</p>
<p>遵循“先进后出”/“后进先出”原则。</p>
<p>每个方法执行的同时都会创建一个栈帧，<strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。</p>
<p><img src="https://i.loli.net/2020/06/14/7o6mMQK8WFiygsa.png" alt="image-20200614204851497"></p>
<p>具体流程可见图：</p>
<p><img src="https://i.loli.net/2020/06/14/rGzFfoEv5mlqgTP.png" alt="image-20200614203637997"></p>
<ol>
<li>栈帧 2是最先被调用的方法，先入栈</li>
<li>然后方法 2 又调用了方法1，栈帧 1处于栈顶的位置</li>
<li>栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1和栈帧 2</li>
<li>线程结束，栈释放</li>
</ol>
<h3 id="栈能触发的异常"><a href="#栈能触发的异常" class="headerlink" title="栈能触发的异常"></a>栈能触发的异常</h3><p>说异常可能不太准确，它是错误。</p>
<p>其中异常(Exception)和错误(Error)都是Throwable的子类。</p>
<p>因为栈是线程独有的，他存放实例方法到栈也就是栈帧，所以当栈帧一直增加不减少时就会触发<code>java.lang.StackOverflowError</code>错误，可以通过递归实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">     m();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆-Heap-🔺"><a href="#堆-Heap-🔺" class="headerlink" title="堆(Heap)🔺"></a>堆(Heap)🔺</h2><p>堆是JVM中占用内存最大的地方，也是GC频繁触发的地方。它是所有线程共享的区域。</p>
<p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。</p>
<p>堆内存在逻辑上可以分为：新生代、老年代、元空间/永久区(JVM规范将<strong>方法区描述为堆的一个逻辑部分</strong>)</p>
<p>堆内存在物理上可以分为：新生代、老年代</p>
<p>java7及以前是永久区；Java8以及后是元空间；它们是<strong>方法区</strong>的实现，并不占用堆内存。而且方法区又称为非堆(Non-Heap)</p>
<p>下图描述了他们的关系：</p>
<p><img src="https://i.loli.net/2020/06/14/x6aRTJiHBndLoF7.png" alt="image-20200614212312812"></p>
<h3 id="堆内存的组成"><a href="#堆内存的组成" class="headerlink" title="堆内存的组成"></a>堆内存的组成</h3><p>物理上堆由新生代和老年代组成。它们的占用比例为1：2。其中，新生区又分为了伊甸区(Eden)、幸存0区(S0|from)、幸存1区(S1|to);他们所占空间的比例为8：1：1，其中from区和to区的大小必须一致。因为后续GC的复制算法需要。</p>
<p><img src="https://i.loli.net/2020/06/14/aPpmV5NiKfS8lGQ.png" alt="image-20200614210351571"></p>
<h3 id="堆中数据的清理"><a href="#堆中数据的清理" class="headerlink" title="堆中数据的清理"></a>堆中数据的清理</h3><p>这里只简单的介绍GC(分代收集算法)。</p>
<p>GC分为两种：</p>
<ol>
<li>YGC、Minor GC，轻GC；新生代中Eden区爆满后触发，复制Eden区和from区中存活的实例到to区，然后清空Eden区和from区。经常触发，执行速度是FGC的10倍。</li>
<li>FGC、MajorGC，重GC；堆中老年代爆满后触发，清除用不到的实例。<strong>若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</strong></li>
</ol>
<p><strong>YGC清理数据时的详细流程🔺</strong></p>
<p>说到这里，我们又得提到新生代中的from区和to区，这两个是动态交换的。from区会变为to区，反之如此。请记住：<strong>from、to谁空谁是to区。</strong></p>
<ol>
<li>eden、SurvivorFrom 复制到 SurvivorTo，年龄+1 。<ol>
<li>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区</li>
<li>当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区）</li>
<li>同时把这些对象的年龄+1</li>
</ol>
</li>
<li>清空 eden、SurvivorFrom <ol>
<li>清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</li>
</ol>
</li>
<li>SurvivorTo和 SurvivorFrom 互换 <ol>
<li>SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区</li>
<li>部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</li>
</ol>
</li>
</ol>
<p><strong>总结起来，YGC就是三部曲：复制-清空-交换。</strong></p>
<h3 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h3><p><strong>以JDK1.8+HotSpot为例</strong></p>
<p>HotSpot的正式发布名称为”Java HotSpot Performance Engine”，是Java虚拟机的一个实现，包含了服务器版和桌面应用程序版，现时由Oracle维护并发布。它利用JIT及自适应优化技术（自动查找性能热点并进行动态优化，这也是HotSpot名字的由来）来提高性能。</p>
<h4 id="jdk7-8"><a href="#jdk7-8" class="headerlink" title="jdk7|8"></a>jdk7|8</h4><p>jdk7和jdk8的区别是方法区的实现分别为永久代和元空间。而永久代和元空间的最大区别就是：</p>
<ol>
<li>永久代使用Java堆的内存存储字符串池和类的静态变量，类的描述数据使用方法区的内存</li>
<li>元空间使用的是本机物理内存，不是JVM内存</li>
</ol>
<p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>
<p>如下图jdk7|8的调优参数：</p>
<p><img src="https://i.loli.net/2020/06/15/587u9oWsKxZCBy4.png" alt="jdk7"></p>
<br/>

<p><img src="https://i.loli.net/2020/06/15/bahMnJX7ArLS36F.png" alt="jdk8"></p>
<h4 id="调优简介"><a href="#调优简介" class="headerlink" title="调优简介"></a>调优简介</h4><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>设置初始分配大小，默认物理内存的1/64</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆最大内存分配，默认物理内存的1/4</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细的GC处理日志</td>
</tr>
</tbody></table>
<p>ps：<code>-XX:+PrintGCDetails</code>在jdk11中已过时，需要使用<code>-Xlog:gc*</code>，再次声明本文章基于jdk8。</p>
<p><font color='red'>我们一般在调优时，Xms一般和Xmx的大小要一致！！！</font></p>
<ol>
<li>如果二者不等，最开始的时候堆大小是Xms，随着heap内存消耗，jvm很有可能需要申请更大的空间直到Xmx；相似的，jvm在申请到Xmx空间时可能又用不了，这时会缩小jvm空间，这样，虽然可以动态调整jvm堆申请的大小，但是每一次调整都需要一定的系统开销（jvm与os之间）。但是，注意前提——生产环境，生产环境意味着一台机器或者一个容器只有一个服务，独占机器意味着没有必要调整jvm大小，直接分配Xmx就行了。否则每一次调整都可能会有开销。只有在开发环境，比如个人电脑，运行的进程特别多，jvm内存动态调整才可能有必要。</li>
<li>另外，在产环境的这一前提下，如果最开始堆大小是Xms，也意味着可能会有比较多的gc，影响性能。</li>
</ol>
<p>为了验证默认值，我们不设置调优参数，查看堆的初始内存和最大内存为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory() ;<span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory() ;<span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MAX_MEMORY = &quot;</span> + maxMemory + <span class="string">&quot;（字节）、&quot;</span> + (maxMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);<span class="comment">// MAX_MEMORY = 2095054848（字节）、1998.0MB</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TOTAL_MEMORY = &quot;</span> + totalMemory + <span class="string">&quot;（字节）、&quot;</span> + (totalMemory / (<span class="keyword">double</span>)<span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);<span class="comment">// TOTAL_MEMORY = 132120576（字节）、126.0MB</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>电脑配置如下：</p>
<p><img src="https://i.loli.net/2020/06/15/ZyH6CsEuBVoGzjQ.png" alt="image-20200615102554114"></p>
<p>但是你可能说结果和你自己计算的有点出入，这是因为计算机计算大小是不是按照1024倍计算的，而是按照1000倍计算的。所以大小有点出入。</p>
<h4 id="idea如何调参"><a href="#idea如何调参" class="headerlink" title="idea如何调参"></a>idea如何调参</h4><p>选择指定运行的入口类，添加JVM调优参数<code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code>，这里的参数只为了展示。</p>
<p><img src="https://i.loli.net/2020/06/15/xz9AQKHoh6YbU28.png" alt="image-20200615103152974"></p>
<p>然后运行程序，就会打印详细的GC信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MAX_MEMORY &#x3D; 1029177344（字节）、981.5MB</span><br><span class="line">TOTAL_MEMORY &#x3D; 1029177344（字节）、981.5MB</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 305664K, used 20971K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 262144K, 8% used [0x00000000eab00000,0x00000000ebf7afb8,0x00000000fab00000)</span><br><span class="line">  from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)</span><br><span class="line">  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)</span><br><span class="line"> ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)</span><br><span class="line">  object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)</span><br><span class="line"> Metaspace       used 3254K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h4 id="如何查看GC日志"><a href="#如何查看GC日志" class="headerlink" title="如何查看GC日志"></a>如何查看GC日志</h4><p>因为我们堆内存有点大，不容易触发GC垃圾回收机制，所以我们手动把堆内存设置为10M，然后就能频繁的看到垃圾回收的日志了。</p>
<p>参数：<code>-Xms8m -Xmx8m -XX:+PrintGCDetails</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;www.atguigu.com&quot;</span> ;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出意外，最后得定会出现<code>java.lang.OutOfMemoryError</code>错误！</p>
<p><img src="https://i.loli.net/2020/06/15/RUiG7Yq1SFQMh8P.png" alt="image-20200615150223412"></p>
<h5 id="YGC日志查看"><a href="#YGC日志查看" class="headerlink" title="YGC日志查看"></a>YGC日志查看</h5><p><img src="https://i.loli.net/2020/06/15/zWN6owGjseMJPLO.png" alt="image-20200615154014582"></p>
<h5 id="FGC日志查看"><a href="#FGC日志查看" class="headerlink" title="FGC日志查看"></a>FGC日志查看</h5><p><img src="https://i.loli.net/2020/06/15/bPnZpI7M9AesVJl.png" alt="image-20200615154451980"></p>
<h1 id="JVM中堆、栈、方法区的关系"><a href="#JVM中堆、栈、方法区的关系" class="headerlink" title="JVM中堆、栈、方法区的关系"></a>JVM中堆、栈、方法区的关系</h1><p>如下图：</p>
<p><img src="https://i.loli.net/2020/06/14/MOsHrGPNjxIWlTn.png" alt="image-20200614204823712"></p>
<ol>
<li>Java栈中存到的引用对象的指针，它指向堆中实例的地址</li>
<li>而堆中每个实例都存放着类模板(类元数据)的地址，可以通过实例获取类模板信息Class</li>
</ol>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>上述在堆一节中说了GC的流程，那只是简单叙述流程。这里主要说一下GC(jdk1.8)本身。</p>
<p>jdk8的默认垃圾回收器为<code>ParallelGC/ParallelOld</code>，自jdk9及以后默认垃圾回收器为<code>G1</code>！！</p>
<p><font color='red'><strong><a href="GC2019.mmap" title="GC思维脑图">点击下载</a>思维脑图文件~！</strong></font></p>
<h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><blockquote>
<p><del>引用计数法</del></p>
</blockquote>
<blockquote>
<p>可达性分析</p>
</blockquote>
<p>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。</p>
<p>要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象<strong>至少要经过两次标记 过程</strong>。<strong>两次标记后仍然是可回收对象，则将面临回收。</strong> </p>
<p>GCROOT包含：</p>
<ol>
<li>栈中的局部变量</li>
<li>本地方法栈中的引用对象</li>
<li>方法区中的常量</li>
<li>方法区中的静态引用</li>
</ol>
<h2 id="GC总体概述"><a href="#GC总体概述" class="headerlink" title="GC总体概述"></a>GC总体概述</h2><p><img src="https://i.loli.net/2020/06/15/3Ejz9whXLPIrZMY.png" alt="image-20200615155056616"></p>
<p>JVM在进行GC时，<strong>并非每次都对上面三个内存区域一起回收的</strong>，<strong>大部分时候回收的都是指新生代。</strong><br><strong>因此GC按照回收的区域又分了两种类型</strong>，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC；它们分别在Eden区、老年代区满的时候触发。</p>
<p><strong><font color="blue">YGC与FGC的区别：</font></strong></p>
<ol>
<li>普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，<strong>因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快</strong>。 </li>
<li>全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。<strong>Major GC的速度一般要比Minor GC慢上10倍以上，FGC会暂停应用执行</strong> </li>
</ol>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>GC四大算法分别为：引用计数法、复制算法、标记清除算法、标记整理算法。</p>
<p>其中YGC采用的就是复制算法；FGC使用的是标记清除算法、标记整理算法的混合实现(分代收集算法)。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这也就是需要回收的对象。</p>
<p><code>引用计数算法</code>是对象记录自己被多少<strong>程序</strong>引用，引用计数为零的对象将被清除。</p>
<p><code>计数器</code>表示的是有多少程序引用了这个对象（被引用数）。计数器是无符号整数。</p>
<p><img src="https://i.loli.net/2020/06/15/ZdxNiOwt1JSLYnj.png" alt="image-20200615161600017"></p>
<p>由此描述可知，这个算法的<strong>缺点</strong>很明显：</p>
<ol>
<li>每次对象赋值时均要维护引用计数器，计数器本身也有消耗</li>
<li>很难处理循环引用</li>
</ol>
<p>所以JVM的实现一般不采用这种算法。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>年轻代中使用的是YGC，这种GC算法采用的是复制算法(Copying)</p>
<p><img src="https://i.loli.net/2020/06/15/qVmjPgIBw7LlaDU.png" alt="image-20200615163630713"></p>
<p><strong>原理</strong></p>
<p>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，<strong>如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中</strong>，也即一旦收集后，Eden是就变成空的了。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p>
<p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p>
<p><strong>解释</strong></p>
<p> HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在<font color="red">年轻代的垃圾回收算法使用的是复制算法</font>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。<font color="red">复制算法不会产生内存碎片。</font></p>
<p><img src="https://i.loli.net/2020/06/15/uPftgIV8Bx5rls2.png" alt="image-20200615164021508"></p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p><img src="https://i.loli.net/2020/06/15/mDogrwKbJUveEGX.png" alt="image-20200615164046258"></p>
<p>因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。<strong>缺点</strong></p>
<ol>
<li>它浪费了一半的内存，这太要命了。</li>
<li>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费(to区)。</li>
</ol>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p><img src="https://i.loli.net/2020/06/15/z4LGqUaPE5XMBol.png" alt="image-20200615164224570"></p>
<p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候<strong>，GC线程就会被触发并将程序暂停</strong>，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p>
<p>主要进行两项工作，第一项则是标记，第二项则是清除。<br>  标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。<br>  清除：遍历整个堆，把标记的对象清除。<br>  缺点：<strong>此算法需要暂停整个应用，会产生内存碎片</strong> </p>
<h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><p><img src="https://i.loli.net/2020/06/15/ehJvtqd5X7ZxBbw.png" alt="image-20200615164358786"></p>
<p>在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。<br>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 </p>
<p>　　标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</p>
<p><strong>缺点</strong></p>
<p>标记/整理算法唯一的缺点就是<strong>效率也不高</strong>，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。<br><strong>从效率上来说，标记/整理算法要低于复制算法。</strong></p>
<p>最后，老年代FGC采用的是：</p>
<p><img src="https://i.loli.net/2020/06/15/AgHUXcsywQkeGon.png" alt="image-20200615164521365"></p>
<h2 id="GC-分代收集算法-VS-分区收集算法"><a href="#GC-分代收集算法-VS-分区收集算法" class="headerlink" title="GC 分代收集算法 VS 分区收集算法"></a>GC 分代收集算法 VS 分区收集算法</h2><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的 GC 算法    </p>
<h4 id="在新生代-复制算法"><a href="#在新生代-复制算法" class="headerlink" title="在新生代-复制算法"></a>在新生代-复制算法</h4><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量 存活对象的复制成本就可以完成收集.</p>
<h4 id="在老年代-标记整理算法"><a href="#在老年代-标记整理算法" class="headerlink" title="在老年代-标记整理算法"></a>在老年代-标记整理算法</h4><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标 记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存</p>
<h3 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h3><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次 GC 所产生的停顿</p>
<h2 id="GC-垃圾收集器"><a href="#GC-垃圾收集器" class="headerlink" title="GC 垃圾收集器"></a>GC 垃圾收集器</h2><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法； 年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p>
<p><img src="https://i.loli.net/2020/11/04/7RovBmiPsN29WnV.png" alt="Snipaste_2020-11-04_15-12-10"></p>
<h3 id="Serial-垃圾收集器（单线程、复制算法）"><a href="#Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="Serial 垃圾收集器（单线程、复制算法）"></a><del>Serial 垃圾收集器（单线程、复制算法）</del></h3><p><strong>Serial（英文连续）是最基本垃圾收集器</strong>，<strong>使用复制算法</strong>，曾经是JDK1.3.1 之前新生代唯一的垃圾 收集器。Serial 是一个单线程的收集器，<strong>它不但只会使用一个 CPU 或一条线程去完成垃圾收集工 作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</strong> Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限 定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，<strong>因此 Serial 垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</strong></p>
<h3 id="ParNew-垃圾收集器（Serial-多线程）"><a href="#ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="ParNew 垃圾收集器（Serial+多线程）"></a>ParNew 垃圾收集器（Serial+多线程）</h3><p>ParNew 垃圾收集器其实是 <strong>Serial 收集器的多线程版本</strong>，<strong>也使用复制算法，</strong>除了使用多线程进行垃 圾收集之外，其余的行为和 Serial 收集器完全一样，<strong>ParNew 垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。</strong></p>
<p><strong>ParNew 收集器默认开启和 CPU 数目相同的线程数</strong>，可以通过-XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。</p>
<p> ParNew虽然是除了多线程外和Serial 收集器几乎完全一样。</p>
<h3 id="Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="Parallel Scavenge 收集器（多线程复制算法、高效）"></a>Parallel Scavenge 收集器（多线程复制算法、高效）</h3><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，<strong>同样使用复制算法，也是一个多线程的垃 圾收集器</strong>，<font color="red">它重点关注的是程序达到一个可控制的吞吐量</font>（Thoughput，CPU 用于运行用户代码 的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）， <font color="red">高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而 <strong>不需要太多交互的任务</strong>。</font>自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别。</p>
<h3 id="Serial-Old-收集器（单线程标记整理算法-）"><a href="#Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="Serial Old 收集器（单线程标记整理算法 ）"></a>Serial Old 收集器（单线程标记整理算法 ）</h3><p><strong>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法， 这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。</strong> </p>
<p>在 Server 模式下，主要有两个用途：</p>
<ol>
<li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li>
<li> 作为年老代中使用 CMS 收集器的后备垃圾收集方案。</li>
</ol>
<hr>
<p><strong>新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图</strong>：</p>
<p><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/Snipaste_2020-11-04_15-25-28.png" alt="Snipaste_2020-11-04_15-25-28"></p>
<p><strong>新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使 用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：</strong></p>
<p><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/Snipaste_2020-11-04_15-27-01.png" alt="Snipaste_2020-11-04_15-27-01"></p>
<h3 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h3><p><strong>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法</strong>，在 JDK1.6 才开始提供。 在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只 能保证新生代的吞吐量优先，无法保证整体的吞吐量，<strong>Parallel Old 正是为了在年老代同样提供吞 吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略</strong>。 新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图</p>
<p><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/Snipaste_2020-11-04_15-56-57.png" alt="Snipaste_2020-11-04_15-56-57"></p>
<h3 id="CMS-收集器（多线程标记清除算法）"><a href="#CMS-收集器（多线程标记清除算法）" class="headerlink" title="CMS 收集器（多线程标记清除算法）"></a>CMS 收集器（多线程标记清除算法）</h3><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，<font color="red">其最主要目标是获取最短垃圾 回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法</font>。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p>
<ol>
<li>初始标记</li>
<li>并发标记（不需要暂停工作线程。）</li>
<li>重新标记</li>
<li>并发清除（不需要暂停工作线程。）</li>
</ol>
<h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h4><p>只是标记一下 <strong>GC Roots 能直接关联的对象</strong>，速度很快，<strong>仍然需要暂停所有的工作线程。</strong></p>
<h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h4><p>进行 GC Roots 跟踪的过程，和用户线程一起工作，<strong>不需要暂停工作线程。</strong></p>
<h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h4><p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，<strong>仍然需要暂停所有的工作线程。</strong></p>
<h4 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h4><p>清除 GC Roots 不可达对象，和用户线程一起工作，<strong>不需要暂停工作线程。由于耗时最长的并 发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行。</strong></p>
<p><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/Snipaste_2020-11-04_16-10-18.png" alt="Snipaste_2020-11-04_16-10-18"></p>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收 集器两个最突出的改进是：</p>
<ol>
<li>基于标记-整理算法，<strong>不产生内存碎片</strong>。 </li>
<li> 可以非常精确控制停顿时间，在<strong>不牺牲吞吐量前提下</strong>，实现低停顿垃圾回收。</li>
</ol>
<p><strong>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域 的垃圾收集进度</strong>，同时在后台维护一个优先级列表，每次根据所允许的收集时间，<strong>优先回收垃圾 最多的区域</strong>。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收 集效率。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Xiangjie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://awslzhang.top/2020/06/14/%E4%BB%80%E4%B9%88%E6%98%AFJVM/">https://awslzhang.top/2020/06/14/%E4%BB%80%E4%B9%88%E6%98%AFJVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://awslzhang.top" target="_blank">zxj</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/06/14/fGXnluFNIw3hgZj.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/15/%E4%BB%80%E4%B9%88%E6%98%AFJMM/"><img class="prev-cover" src="https://images.pexels.com/photos/924824/pexels-photo-924824.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JMM内存模型</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8FFmpeg%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91/"><img class="next-cover" src="https://i.loli.net/2020/06/09/RO5Fb9ac84fBIlJ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">记一次调用FFmpeg处理视频</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Xiangjie</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XiangJie-Zhang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:qluzxj@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJVM"><span class="toc-number">1.</span> <span class="toc-text">什么是JVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">JVM体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader"><span class="toc-number">2.1.</span> <span class="toc-text">类加载器ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassLoader%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">ClassLoader的种类及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stack"><span class="toc-number">2.2.</span> <span class="toc-text">本地方法栈(Native Method Stack)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3-Native-Interface"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法接口(Native Interface)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-Program-Counter-Register"><span class="toc-number">2.4.</span> <span class="toc-text">程序计数器(Program Counter Register)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="toc-number">2.5.</span> <span class="toc-text">方法区(Method Area)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%88-Stack"><span class="toc-number">2.6.</span> <span class="toc-text">Java栈(Stack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">栈运行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%83%BD%E8%A7%A6%E5%8F%91%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.2.</span> <span class="toc-text">栈能触发的异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86-Heap-%F0%9F%94%BA"><span class="toc-number">2.7.</span> <span class="toc-text">堆(Heap)🔺</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.7.1.</span> <span class="toc-text">堆内存的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">堆中数据的清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">2.7.3.</span> <span class="toc-text">堆参数调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk7-8"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">jdk7|8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%AE%80%E4%BB%8B"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">调优简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#idea%E5%A6%82%E4%BD%95%E8%B0%83%E5%8F%82"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">idea如何调参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BGC%E6%97%A5%E5%BF%97"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">如何查看GC日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#YGC%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.7.3.4.1.</span> <span class="toc-text">YGC日志查看</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FGC%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.7.3.4.2.</span> <span class="toc-text">FGC日志查看</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E4%B8%AD%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text">JVM中堆、栈、方法区的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC"><span class="toc-number">4.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE"><span class="toc-number">4.1.</span> <span class="toc-text">如何确定垃圾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E6%80%BB%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">GC总体概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">标记清除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">标记整理法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-VS-%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">GC 分代收集算法 VS 分区收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">在新生代-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E8%80%81%E5%B9%B4%E4%BB%A3-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">在老年代-标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">分区收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">GC 垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">4.5.1.</span> <span class="toc-text">Serial 垃圾收集器（单线程、复制算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Serial-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">4.5.2.</span> <span class="toc-text">ParNew 垃圾收集器（Serial+多线程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E3%80%81%E9%AB%98%E6%95%88%EF%BC%89"><span class="toc-number">4.5.3.</span> <span class="toc-text">Parallel Scavenge 收集器（多线程复制算法、高效）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95-%EF%BC%89"><span class="toc-number">4.5.4.</span> <span class="toc-text">Serial Old 收集器（单线程标记整理算法 ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">4.5.5.</span> <span class="toc-text">Parallel Old 收集器（多线程标记整理算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">4.5.6.</span> <span class="toc-text">CMS 收集器（多线程标记清除算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0"><span class="toc-number">4.5.6.1.</span> <span class="toc-text">初始标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">4.5.6.2.</span> <span class="toc-text">并发标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0"><span class="toc-number">4.5.6.3.</span> <span class="toc-text">重新标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4"><span class="toc-number">4.5.6.4.</span> <span class="toc-text">并发清除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.5.7.</span> <span class="toc-text">G1 收集器</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/23/Flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89%E5%92%8CWaterMark/" title="Flink的时间语义和watermark"><img src="https://flink.apache.org/img/flink-header-logo.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flink的时间语义和watermark"/></a><div class="content"><a class="title" href="/2020/12/23/Flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89%E5%92%8CWaterMark/" title="Flink的时间语义和watermark">Flink的时间语义和watermark</a><time datetime="2020-12-23T10:59:07.000Z" title="发表于 2020-12-23 18:59:07">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/17/Flink-API/" title="Flink Api学习"><img src="https://flink.apache.org/img/flink-header-logo.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flink Api学习"/></a><div class="content"><a class="title" href="/2020/12/17/Flink-API/" title="Flink Api学习">Flink Api学习</a><time datetime="2020-12-17T12:36:28.000Z" title="发表于 2020-12-17 20:36:28">2020-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/17/ready/" title="ready!"><img src="https://images.pexels.com/photos/924824/pexels-photo-924824.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ready!"/></a><div class="content"><a class="title" href="/2020/12/17/ready/" title="ready!">ready!</a><time datetime="2020-12-16T16:02:06.000Z" title="发表于 2020-12-17 00:02:06">2020-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Flink学习笔记"><img src="https://flink.apache.org/img/flink-header-logo.svg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flink学习笔记"/></a><div class="content"><a class="title" href="/2020/12/16/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Flink学习笔记">Flink学习笔记</a><time datetime="2020-12-16T12:29:56.000Z" title="发表于 2020-12-16 20:29:56">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/06/k8s%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%BB%BAJava%E9%A1%B9%E7%9B%AE/" title="k8s集群监控、高可用以及部署自建Java项目"><img src="https://zxj-typora.oss-cn-shanghai.aliyuncs.com/img/下载.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s集群监控、高可用以及部署自建Java项目"/></a><div class="content"><a class="title" href="/2020/12/06/k8s%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2%E8%87%AA%E5%BB%BAJava%E9%A1%B9%E7%9B%AE/" title="k8s集群监控、高可用以及部署自建Java项目">k8s集群监控、高可用以及部署自建Java项目</a><time datetime="2020-12-06T01:26:41.000Z" title="发表于 2020-12-06 09:26:41">2020-12-06</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Xiangjie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script></div></body></html>